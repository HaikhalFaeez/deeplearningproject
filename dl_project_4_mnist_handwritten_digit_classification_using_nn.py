# -*- coding: utf-8 -*-
"""DL Project 4 - MNIST Handwritten Digit Classification using NN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1of5slb38bvivo-sfrgZ5PGig0r5_cKws

1.  To classify the image of a handwritten single digit number from 0 to 9 - Classification Problem
2.  Deep Learning Model - Neural Network (NN)
3.  Work Flow

    *   Collect MNIST Handwritten Data - Keras Dataset
    *   Data Pre-Processing
    *   Train-Test Split
    *   Deep Learning Model - Neural Network Model (NN)
    *   DL Model Evaluation
    *   Develop Prediction System - Feed new data to trained model to predict the handwritten digit number

Importing the Dependencies
"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import cv2
from google.colab.patches import cv2_imshow
from PIL import Image
import tensorflow as tf
tf.random.set_seed(3) # similar in random_state function
from tensorflow import keras
from keras.datasets import mnist # import mnist datasets from keras datasets
from tensorflow.math import confusion_matrix

"""Data Collection and Image Processing"""

# Loading MNIST datasets from keras.datasets

(X_train, Y_train), (X_test, Y_test) = mnist.load_data()

type(X_train)

print(X_train.shape, Y_train.shape, X_test.shape, Y_test.shape)

# X_train - 60 000 images with dimension of 28 x 28 pixels (1 channel - grayscale image)
# Y_train - 60 000 images (1 channel - grayscale image)
# X_test - 10 000 images with dimension of 28 x 28 pixels (1 channel - grayscale image)
# Y_test - 10 000 images (1 channel - grayscale image)

# Training data - 60 000 images
# Test data - 10 000 images

# Images dimension - 28 x 28 pixels
# Channel 1 image - grayscale images

print(X_train[10]) # print the eleventh element

print(X_train[10].shape) # single image dimension

# displaying the image

plt.imshow(X_train[50])
plt.show()

# print the corresponding label

print(Y_train[50])

"""Image Labels"""

print(Y_train.shape, Y_test.shape)

# Method 1 - To find the different elements in the labeled dataset (target)
# use unique function in numpy

# unique values in Y_train
print(np.unique(Y_train))

# unique values in Y_test
print(np.unique(Y_test))

# Method 2 - To find the different elements in the labeled dataset (target)
# use One Hot Encoding
      # eg. if there is 10 elements with the values of 0 to 9, the 0 value will be displayed as 1 and the rest as 0 = [1 0 0 0 0 0 0 0 0 0]
      # and if there is 10 elements with the values of 0 to 9, the 0 value will be displayed as 1 and the rest as 0 = [1 0 0 0 0 0 0 0 0 0]

"""Normalization

*  The current values in the numpy array is in the range of 0 - 255, so the values need to be scaled/normalized to convert the values from 0 - 255 to 0 - 1 only to make it easy for the NN to process
"""

# scaling/normalized the values

X_train = X_train/255
X_test = X_test/255

print(X_train[10]) # print a single image numpy array

"""Model Training - Neural Network (NN)"""

# setting up the layers of the NN

model = keras.Sequential([

                          keras.layers.Flatten(input_shape=(28,28)), # Flatten the matrix of 28 x 28 to a single array/vector # if work on RGB image = (28,28,3)
                          keras.layers.Dense(50, activation='relu'),
                          keras.layers.Dense(50, activation='relu'),
                          keras.layers.Dense(10, activation='sigmoid') # output neurons - the output have 10 output (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

])

# compiling the NN

model.compile(

              optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy']

)

# training the NN

model.fit(X_train, Y_train, epochs=10)

"""Model Evaluation"""

# accuracy on test data

loss, accuracy = model.evaluate(X_test, Y_test)

# Training data accuracy = 98.9 %
# Test data accuracy = 96.6 %

print(X_test.shape)

# first data in X_test data

plt.imshow(X_test[0])
plt.show()

# print the actual/true label in Y_test data

print(Y_test[0])

# predict all the data in X_test

Y_pred = model.predict(X_test)

print(Y_pred.shape)

print(Y_pred[0])

# the result will not show the exact label but will show the probability for each class/label for each data point

# converting the prediction probabilities to class label for 1 data point

label_for_first_image = np.argmax(Y_pred[0])
print(label_for_first_image)

# converting the prediction probabilities to class label for all data points

Y_pred_labels = [np.argmax(i) for i in Y_pred]
print(Y_pred_labels)

"""Y_test --> True labels

X_pred_labels --> Predicted labels

Confusion Matrix
"""

conf_matrix = confusion_matrix(Y_test, Y_pred_labels)

print(conf_matrix)

plt.figure(figsize=(15,7))
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues') # fmt='d' - show the value as integer
plt.ylabel('True Labels')
plt.xlabel('Predicted Labels')

"""Building A Predictive System"""

input_image_path = '/content/mnist_digit.png'

input_image = cv2.imread(input_image_path)

type(input_image)

print(input_image)

cv2_imshow(input_image)

input_image.shape

# convert RGB image to Grayscale image

grayscale = cv2.cvtColor(input_image, cv2.COLOR_RGB2GRAY)

grayscale.shape

# resized the image to 28 x 28

input_image_resize = cv2.resize(grayscale,(28,28))

input_image_resize.shape

cv2_imshow(input_image_resize)

# scaling/normalization of the data

input_image_resize = input_image_resize/255

# reshape the image into a single data point, 1 with dimension 28 x 28 = [1,28,28] # if working with RGB, have to add [1,28,28,3]

image_reshaped = np.reshape(input_image_resize, [1,28,28])

input_pred = model.predict(image_reshaped)

print(input_pred)

input_pred_label = np.argmax(input_pred)

print(input_pred_label)

"""Predictive System"""

input_image_path = input('Path of the image to be predicted: ')

input_image = cv2.imread(input_image_path)

cv2_imshow(input_image)

grayscale = cv2.cvtColor(input_image, cv2.COLOR_RGB2GRAY)

input_image_resize = cv2.resize(grayscale,(28,28))

input_image_resize = input_image_resize/255

image_reshaped = np.reshape(input_image_resize, [1,28,28])

input_pred = model.predict(image_reshaped)

input_pred_label = np.argmax(input_pred)

print('The Handwitten Digit is: ', input_pred_label)